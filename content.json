[{"title":"SSM框架Spring篇","date":"2017-12-23T02:53:32.000Z","path":"2017/12/23/SSM框架Spring篇/","text":"SSM框架——Spring简介 Spring是一个开放源代码的设计层面框架，他解决的是业务逻辑层和其他各层的松耦合问题，因此它将面向接口的编程思想贯穿整个系统应用。Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson创建。简单来说，Spring是一个分层的JavaSE/EEfull-stack(一站式) 轻量级开源框架。 Spring是一个开源框架，为了解决企业应用开发的复杂性而创建的，但现在已经不止应用于企业应用。 是一个轻量级的控制反转（IoC）和面向切面（AOP）的容器框架。 从大小于开销两方面而言Spring都是轻量级的。 通过控制反转（IoC）的技术达到松耦合的目的。 提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑于系统服务进行内聚性的开发。 包含并管理应用对象的配置和生命周期。 将简单的组件配置组合成为复杂的应用（框架）。 ​ Spring作用 容器 提供了对多种技术的支持 JMS MQ支持 UnitTest AOP（事务管理，日志等） 提供了众多方便应用的辅助类（JDBC Template等） 对主流应用框架（Hibernate等）提供了良好的支持 适用范围 构建企业应用（SpringMVC+Spring+Hibernate/ibatis） 单独使用Bean容器（Bean管理） 单独使用AOP进行切面处理 对消息的支持等。 控制反转（IoC）控制权的转移，应用程序本身不负责依赖对象的创建和维护，而是由外部容器（Spring容器）负责创建和维护。 业务对象进入Spring容器，然后通过配置的元数据，生产符合我们需要的对象，之后我们需要使用时直接从容器拿出来用。 依赖注入（Dependency Injection）：控制被反转之后，获得依赖对象的过程由自身管理变为了有IoC容器主动注入。一种实现IoC的方法 Bean容器初始化文件： 1FileSystemXmlApplicationContext context = new FileSystemXmlApplicationContext(\"F:/workspace/appcontext.xml\"); Classpath： 1ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:spring-context.xml\"); Web应用： 12345678&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;servlet&gt; &lt;servlet-name&gt;context&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; Spring注入启动Spring容器加载bean配置的时候，完成对变量的赋值行为，常用的两种注入方式： InjectionServiceImpl 1234567891011121314151617181920212223242526package com.imooc.ioc.injection.service;import com.imooc.ioc.injection.dao.InjectionDAO;public class InjectionServiceImpl implements InjectionService &#123; private InjectionDAO injectionDAO; //构造器注入 public void InjectionServiceImpl(InjectionDAO injectionDAO) &#123; this.injectionDAO = injectionDAO; &#125; //设值注入 public void setInjectionDAO(InjectionDAO injectionDAO) &#123; this.injectionDAO = injectionDAO; &#125; public void save(String arg) &#123; //模拟业务操作 System.out.println(\"Service接受参数：\" + arg); arg += \";\" + this.hashCode(); injectionDAO.save(arg); &#125;&#125; 设值注入：通过set()方法注入 Spring-injection.xml 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"injectionService\" class=\"com.imooc.ioc.injection.service.InjectionServiceImpl\"&gt; &lt;property name=\"injectionDAO\" ref=\"injectionDAO\"/&gt; &lt;/bean&gt; &lt;bean id=\"injectionDAO\" class=\"com.imooc.ioc.injection.dao.InjectionDAOImpl\"&gt;&lt;/bean&gt;&lt;/beans&gt; 构造注入：通过构造方法注入Spring-injection.xml 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"injectionService\" class=\"com.imooc.ioc.injection.service.InjectionServiceImpl\"&gt; &lt;constructor-arg name=\"injectionDAO\" ref=\"injectionDAO\"/&gt; &lt;/bean&gt; &lt;bean id=\"injectionDAO\" class=\"com.imooc.ioc.injection.dao.InjectionDAOImpl\"&gt;&lt;/bean&gt;&lt;/beans&gt; BeanBean配置项 Id：bean的唯一标识 Class：具体要实例化的类（必须配置的） Scope：作用域 Constructor arguments：构造器的参数 Properties：属性 Autowiring mode：自动装配模式 lazy-initialization mode：懒加载模式 Initialization/destruction method：初始化和销毁的方法 Bean的作用域 singleton：单例，指一个Bean容器中只存在一份。 property：每次请求（每次使用）创建新的实例，destroy方式不生效。 request：每次http请求创建一个实例且仅在当前request内有效。 session：每次http请求创建，当前session内有效。 global session：基于portlet的web中有效（portlet定义了global session），如果是在web中，同session。 Bean的生命周期 初始化 实现org.springframework.beans.factory.InitializingBean接口，覆盖afterPropertiesSet方法 配置init-method 1&lt;bean id=\"exampleInitBean\" class=\"examples.ExampleBean\" init-method=\"init\" /&gt; 12345public class ExampleBean &#123; public void init() &#123; // do some initialization work &#125;&#125; 销毁 实现org.springframework.beans.factory.DisposableBean接口，覆盖destory方法 配置destroy-method 123456public class ExampleDisposableBean implements DisposableBean &#123; @Override public void destory() throws Exception &#123; //do something &#125;&#125; 配置全局默认初始化、销毁方法 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\" default-init-method=\"init\" default-destroy-method=\"destroy\"&gt;&lt;/beans&gt; Aware Spring中提供了一些以Aware结尾的接口，实现了Aware接口的bean在被初始化后，可以获取相应资源。 通过Aware接口，可以对Spring相应资源进行操作。 为对Spring进行简单的扩展提供了方便的入口。 Bean的自动装配（Autowiring) No：不做任何操作。 byname：根据属性名自动装配。此选项将检查容器并根据名字查找与属性完全一致的bean，并将其与属性自动装配。 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\" default-autowire=\"byName\"&gt; &lt;bean id=\"autoWiringService\" class=\"com.imooc.autowiring.AutoWiringService\"&gt;&lt;/bean&gt; &lt;!-- 这个bean的id必须和类之中变量名相同 --&gt; &lt;bean id=\"autoWiringDAO\" class=\"com.imooc.autowiring.AutoWiringDAO\"&gt;&lt;/bean&gt; &lt;/beans&gt; 添加属性default-autowire=”byName”。 123456789101112131415package com.imooc.autowiring;public class AutoWiringService &#123; private AutoWiringDAO autoWiringDAO; public void setAutoWiringDAO(AutoWiringDAO autoWiringDAO) &#123; this.autoWiringDAO = autoWiringDAO; &#125; public void say(String word) &#123; this.autoWiringDAO.say(word); &#125; &#125; byType：如果容器中存在一个与指定属性类型相同的bean，那么将与该属性自动装配；如果存在多个该类型bean，那么抛出异常，并指出不能使用byType方式进行自动装配；如果没有找到相匹配的bean，则什么事都不发生。xml配置文件中的bean的id不用和类的变量名相同，但是类型必须相同。 Constructor：与byType方式类似，不同之处在于它应用于构造器参数。如果容器中没有找到与构造器参数类型一致的bean，那么抛出异常。 Resource&amp;ResourceLoader 针对于资源文件的统一接口 Resource UrlResource：URL对应的资源，根据一个URL地址即可构建。 ClassPathResource：获取类路径下的资源文件。 FileSystemResource：获取文件系统里面的资源。 ServletContextResource：ServletContext封装的资源，用于访问ServletContext环境下的资源。 InputStreamResource：针对于输入流封装的资源。 ByteArrayResource：针对于字节数组封装的资源。 ResourceLoader：对resource进行加载的类。 123public interface ResourceLoader &#123; Resource getResource(String location);&#125; 123456//依赖于ApplicationContext而输入路径Resource template = ctx.getResource(\"some/resource/path/myTemplate.txt\");//从classpath路径读取文件Resource template = ctx.getResource(\"classpath:some/resource/path/myTemplate.txt\");//从文件系统读取URL路径Resource template = ctx.getResource(\"file:/some/resource/path/myTemplate.txt\"); Bean管理的注解实现classpath扫描与组件管理 从Spring3.0开始，Spring JavaConfig项目提供了很多特性，包括使用java而不是XML定义bean，比如@Configuration，@Bean，@Import，@DependsOn。 @Component是一个通用注解，可用于任何bean。 @Repository，@Service，@Controller是更有针对性的注解 @Repository通常用于注解DAO类，即持久层 @Service通常用于注解Service类，即服务层 @Controller通常用于Controller类，即控制层（MVC） 许多Spring提供的注解可以作为自己的代码，即“元数据注解”，元注解是一个简单的注解，可以应用到另一个注解 1234567@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Component // Spring will see this and treat @Service in the same way as @Componentpublic @interface Service &#123; // ... . 除了value()，元注解还可以有其他的属性，允许定制 123456@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Scope(\"session\")public @interface SessionScope &#123; ScopedProxyMode proxyMode() default ScopedProxyMode.DEFAULT ​ 类的自动检测与注册bean Spring可以自动检测类并注册Bean到ApplicationContext中 123456789@Servicepublic class SimpleMovieLister &#123; private MovieFinder movieFinder; @Autowired public SimpleMovieLister (MovieFinder movieFinder) &#123; this.MovieFinder = movieFinder; &#125;&#125; 1234@Repositorypublic class JpaMovieFinder implements MovieFinder &#123; // implementation elided for clarity&#125; 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:annotation-scan base-package=\"org.example\"/&gt;&lt;/beans&gt; 使用过滤器进行自定义扫描 12345678&lt;beans&gt; &lt;context:component-scan base-package=\"org.example\"&gt; &lt;context:include-filter type=\"regex\" expression=\".*Stub.*Repository\" /&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Repository\" /&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; 忽略所有的@Repository注解并用“Stub”代替。 如何定义Bean 扫描过程中组件被自动检测，Bean的名称是由BeanNameGenerator生成的（@Component, @Repository, @Service, @Controller都会有个name属性用于显示设置Bean Name） 1234@Service(\"lister\")public class SimpleMovieLister &#123; // ...&#125; 1234@Repositorypublic class MovieFinderImpl implements MovieFinder &#123; // ...&#125; 12345678910111213141516171819202122package com.imooc.test.annotation;import org.junit.Test;import org.junit.runner.RunWith;import org.junit.runners.BlockJUnit4ClassRunner;import com.imooc.annotation.BeanAnnotation;import com.imooc.test.base.UnitTestBase;@RunWith(BlockJUnit4ClassRunner.class)public class TestBeanAnnotation extends UnitTestBase &#123; public TestBeanAnnotation() &#123; super(\"classpath*:spring-beanannotation.xml\"); &#125; @Test public void testSay() &#123; SimpleMovieLister bean = super.getBean(\"lister\"); &#125; &#125; 可自定义bean命名策略，实现BeanNameGenerator接口，并一定要包含一个无参数构造器函数 1234&lt;beans&gt; &lt;context:component-scan base-package=\"org.example\" name-generator=\"org.example.MyNameGenerator\" /&gt;&lt;/beans&gt; @Required 适用于bean属性的setter方法 这个注解仅仅表示，受影响的bean属性必须在配置是被填充，通过在bean定义或通过自动装配一个明确的属性值 12345678910public class SimpleMovieLister &#123; private MovieFinder movieFinder; @Required public void setMovieFinder(MovieFinder movieFinder) &#123; this.movieFinder = movieFinder; &#125; // ...&#125; @AutoWired 可以将@Autowired注解为“传统”的setter方法 123456private MovieFinder movieFinder;@Autowiredpublic void setMovieFinder(MovieFinder movieFinder) &#123; this.movieFinder = movieFinder;&#125; 可用于构造器或成员变量 123456789@Autowiredprivate MovieCatalog movieCatalog;private CustomerPreferenceDao customerPreferenceDao;@Autowiredpublic MovieRecommender (CustomerPreferenceDao customerPreferenceDao) &#123; this.customerPreferenceDao = customerPreferenceDao;&#125; 相比于@required作用方位更广。 默认情况下，如果找不到合适的bean将会导致autowiring失败抛出异常，可以通过下面的方式避免 12345678public class SimpleMovieLister &#123; private MovieFinder movieFinder; @Autowired(required=false) public void setMovieFinder(MovieFinder movieFinder) &#123; this.movieFinder = movieFinder; &#125;&#125; 每个类只能有一个构造器被标记为required=true。 Autowired的必要属性，使用@Required注解 可以通过添加注解给需要该类型的数组的字段或方法，以提供ApplicationContext中的所有特定类型的bean 123456private Set&lt;MovieCatalog&gt; movieCatalogs;@Autowiredpublic void setMovieCatalogs(Set&lt;MovieCatalog&gt; movieCatalogs) &#123; this.movieCatalogs = movieCatalogs;&#125; 可以用于装配key为String的Map 123456private Map&lt;String, MovieCatalog&gt; movieCatalogs;@Autowiredpublic void setMovieCatalogs(Map&lt;String, MovieCatalog&gt; movieCatalogs) &#123; this.movieCatalogs = movieCatalogs;&#125; 如果希望数组有序，可以让bean实现org.springframework.core.Ordered接口或使用@Order注解。 @Autowired是由Spring BeanPostProcessor处理的，所以不能在自己的BeanPostProcessor或BeanFactoryPostProcessor类型应用这些注解，这些类型必须通过XML或者Spring的@Bean注解加载。 @Qualifier 按类型自动装配可能多个bean实例的情况，可以使用Spring的@Qualifier注解缩小方位（或指定唯一），也可以用于指定单独的构造器参数或者方法参数。 12345public class MovieRecommender &#123; @Autowired @Qualifier(\"main\") private MovieCatalog movieCatalog;&#125; 1234567891011121314public class MovieRecommender &#123; private MovieCatalog movieCatalog; private CustomerPreferenceDao customerPreferenceDao; @Autowired public void prepare(@Qualifier(\"main\"))MovieCatalog movieCatalog, CustomerPreferenceDao customerPreferenceDao) &#123; this.movieCatalog = movieCatalog; this.customerPreferenceDao = customerPreferenceDao; &#125; // ...&#125; 可用于注解集合类型变量 @Resource Spring还支持使用JSR-250@Resource注解的变量或setter方法，这是以终在Java EE 5和6的通用模式，Spring管理的对象也支持这种模式 @Resource有一个name属性，并且默认Spring解释该值作为被注入bean的名称 12345678910public class SimpleMovieLister &#123; private MovieFinder movieFinder; //如果没有显式的指定resource的名称，默认是从属性名或者setter方法得出 @Resource(name=\"myMovieFinder\") public void setMovieFinder(MovieFinder movieFinder) &#123; this.movieFinder = movieFinder; &#125;&#125; 在Spring2.5中引入支持初始化回调和销毁回调，在CommonAnnotationBeanPostProcessor是Spring的ApplicationContext中注册的 123456789101112public class CachingMovieLister &#123; @PostConstruct public void popularMovieCache() &#123; // populates the movie cache upon initialization... &#125; @PreDestroy public void clearMovieCache() &#123; // clears the movie cache upon destruction... &#125;&#125; @Inject等效于@Autowired，可以使用于类、属性、方法、构造器 12345678910111213import javax.inject.Inject;public class SimpleMovieLister &#123; private MovieFinder movieFinder; @Inject public void setMovieFinder(MovieFinder movieFinder) &#123; this.movieFinder = movieFinder; &#125; // ...&#125; @Named如果想使用特定名称进行依赖注入，可以使用@Named 1234567891011121314import.javax.inject.Inject;import.javax.inject.Named;public class SimpleMovieLister &#123; private MovieFinder movieFinder; @Inject public void setMovieFinder(@Named(\"main\") MovieFinder movieFinder) &#123; this.movieFinder = movieFinder; &#125; // ...&#125; ​ ​ 基于java的容器注解 @Bean标识一个用于配置和初始化一个由SpringIoC容器管理的新对象的方法，类似于XML配置文件的&lt;bean/&gt; 可以在Spring的@Component注解类中使用@Bean注解任何方法，但通常配合@Configuration使用 12345678910@Configurationpublic class AppConfig &#123; // 可以自定义bean name // @Bean(name = \"myFoo\") @Bean public MyService myService() &#123; return new MyServiceImpl(); &#125;&#125; 相当于 123&lt;beans&gt; &lt;bean id=\"myService\" class=\"com.acme.services.MyServiceImpl\" /&gt;&lt;/beans&gt; ini-method和destroy-method 1234567891011121314151617181920212223242526public class Foo &#123; public void init() &#123; public void init() &#123; // initializacion logic &#125; &#125;&#125;public class Bar &#123; public void cleanup() &#123; // destruction logic &#125;&#125;@Configurationpublic class AppConfig &#123; @Bean (initMethod = \"init\") public Foo foo() &#123; return new Foo(); &#125; @Bean (destroyMethod = \"cleanup\") public Bar bar() &#123; return new Bar(); &#125;&#125; 使用@ImportResource和@Value注解进行资源文件读取使用XML配置方式： 12345678910111213&lt;beans&gt; &lt;!-- enable processing of annotations such as @Autowired and @Configuration --&gt; &lt;context:annotation-config/&gt; &lt;context:property-placeholder location=\"classpath:/com/acme/jdbc.properties\"/&gt; &lt;bean class=\"com.acme.AppConfig\"/&gt; &lt;bean class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 使用注解方式： 123456789101112131415161718@Configuration@ImportResource(\"classpath:/com/acme/properties-config.xml\")public class AppConfig &#123; @Value(\"$&#123;jdbc.url&#125;\") private String url; @Value(\"$&#123;jdbc.username&#125;\") private String username; @Value(\"$&#123;jdbc.password&#125;\") private String password; @Bean public DataSource dataSource() &#123; return new DriverManagerDataSource(url, username, password); &#125;&#125; 基于泛型的自动装配12345678910111213@Configurationpublic class MyConfiguration &#123; @Bean public StringStore StringStore() &#123; return new StringStore(); &#125; @Bean public IntegerStore integerStore() &#123; return new IntegerStore(); &#125;&#125; 12345@Autowiredprivate Store&lt;String&gt; s1; // String的泛型，自动装配StringStore的Bean@Autowiredprivate Store&lt;Integer&gt; s2; // Integer的泛型，自动装配Integer的Bean 123// list集合里面的Store对象都是整形的@Autowiredprivate List&lt;Store&lt;Integer&gt;&gt; s; CustomAutowireConfigurer CustomAutowireConfigurer是BeanFactoryPostProcessor的子类，通过它可以注册自己的qualifier注解类型（即使没有使用Spring的@Qualifier注解） 1234567&lt;bean id=\"customAutowireConfigurer\" class=\"org.springframework.beans.factory.annotation.CustomAutowireConfigurer\"&gt; &lt;property name=\"customQualifierTypes\"&gt; &lt;set&gt; &lt;value&gt;example.CustomQualifier&lt;/value&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; 该AutowireCandidateResolver决定自动装配的候选者： 每个bean定义的autowire-candidate值 任何&lt;bean/&gt;中的default-autowire-candidates @Qualifier注解及使用CustomAutowireConfigurer的自定义类型","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/tags/SSM/"}]},{"title":"Servlet学习笔记","date":"2017-12-21T04:00:41.000Z","path":"2017/12/21/Servlet学习笔记/","text":"Servlet学习笔记概述Servlet是在服务器上运行的小程序。一个Servlet就是一个Java类，并且可以通过“请求-响应”编程模型来访问这个驻留在服务器内存里的Servlet程序。 Tomcat容器等级tomcat的容器分为四个等级，Servlet的容器管理Context容器，一个Context对应一个Web工程。 编写Servlet需要重写doGet()和doPost()方法用来处理get与post请求： index.jsp： 12345678&lt;body&gt; &lt;h1&gt;使用MyEclipse创建Servlet小例子&lt;/h1&gt; &lt;hr&gt; &lt;a href=\"servlet/HelloServlet\"&gt;Get方式请求HelloServlet&lt;/a&gt; &lt;form action=\"servlet/HelloServlet\" method=\"post\"&gt; &lt;input type=\"submit\" value=\"Post方式请求HelloServlet\" /&gt; &lt;/form&gt;&lt;/body&gt; servlet/HelloServlet.java： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package servlet;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * Servlet implementation class HelloServlet */@WebServlet(\"/servlet/HelloServlet\")public class HelloServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public HelloServlet() &#123; super(); // TODO Auto-generated constructor stub &#125; /** * @see Servlet#init(ServletConfig) */ public void init(ServletConfig config) throws ServletException &#123; // TODO Auto-generated method stub &#125; /** * @see Servlet#destroy() */ public void destroy() &#123; // TODO Auto-generated method stub &#125; /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub response.setContentType(\"text/html;charset=utf-8\"); System.out.println(\"处理Get()请求\"); PrintWriter out = response.getWriter(); out.print(\"&lt;strong&gt;Hello Servlet!&lt;/strong&gt;\"); &#125; /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub response.setContentType(\"text/html;charset=utf-8\"); System.out.println(\"处理Post()请求\"); PrintWriter out = response.getWriter(); out.print(\"&lt;strong&gt;Hello Servlet!&lt;/strong&gt;\"); &#125;&#125; Servlet执行流程和生命周期 执行流程： Get方式请求HelloServlet。 从web.xml配置文件的servlet-mapping标签中的url-pattern子标签中找到对应href标签的地址，并从servlet-name标签获得对应的servlet文件名称（HelloServlet)。 再从servlet标签找到对应servlet文件所在的地址。 最后从找到的类中找到doGet方法并且执行。 生命周期： 初始化阶段，调用init()方法。 响应客户请求阶段，调用service()方法。由service()方法根据提交方式选择执行doGet()或者doPost()方法。 终止阶段，调用destroy()方法。 Tomcat装载Servlet的三种情况： Servlet容器启动时自动装载某些Servlet，实现它只需要在web.xml文件中的servlet标签之间loadon-startup标签中添加数字，越小表示优先级别越高。 1&lt;loadon-startup&gt;1&lt;/loadon-startup&gt; ​ 在Servlet容器启动后，客户首次向Servlet发送请求。 Servlet类文件被更新后，重新装载Servlet。 Servlet被装载后，Servlet容器创建一个Servlet实例并且调用Servlet的init()方法进行初始化。在Servlet的整个生命周期内，init()方法只被调用一次。 Servlet与JSP内置对象的对应关系 JSP对象 如何获得 out response.getWriter request service方法中的request参数 response service方法中的response参数 session request.getSession()方法 application getServletContext()方法 exception Throwable page this pageContext PageContext Config getServletConfig方法 Servlet路径跳转 绝对路径：完整的路径 123&lt;!--使用相对路径访问HelloServlet --&gt;&lt;!-- /servlet/HelloServlet 第一个/表示服务器的根目录 --&gt;&lt;a href=\"servlet/HelloServlet\"&gt;访问HelloServlet!&lt;/a&gt;&lt;br&gt; ​ 相对路径：相对于当前资源的路径 12&lt;!-- 使用绝对路径 访问HelloServlet,可以使用path变量:path变量表示项目的根目录--&gt;&lt;a href=\"&lt;%=path%&gt;/servlet/HelloServlet\"&gt;访问HelloServlet!&lt;/a&gt;&lt;br&gt; ​ 获取初始化参数在web.xml中配置Servlet时，可以配置一些初始化参数。而在Servlet中可以通过ServletConfig接口提供的方法来取得这些参数。 在servlet3.0之后的版本，可以使用注解而不用在web.xml之中修改。 PS：用myEclipse创建servlet时会自动出现补全void init(ServletConfig config);方法，但是要让注解生效必须使用void init();无参数的方法才行。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package servlet;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.annotation.WebInitParam;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * Servlet implementation class GetInitParameterServlet */@WebServlet( name = \"GetInitParameterServlet\", urlPatterns = \"/servlet/GetInitParameterServlet\", initParams = &#123; @WebInitParam(name = \"username\", value = \"admin\"), @WebInitParam(name = \"password\", value = \"123456\") &#125;)public class GetInitParameterServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; private String username; //用户名 private String password; //密码 /** * @see HttpServlet#HttpServlet() */ public GetInitParameterServlet() &#123; super(); // TODO Auto-generated constructor stub &#125; /** * @see Servlet#init(ServletConfig) */ public void init(ServletConfig config) throws ServletException &#123; this.username = this.getInitParameter(\"username\"); this.password = this.getInitParameter(\"password\"); &#125; /** * @see Servlet#destroy() */ public void destroy() &#123; // TODO Auto-generated method stub &#125; /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request, response); &#125; /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(\"text/html;charset=utf-8\"); PrintWriter out = response.getWriter(); out.println(\"&lt;h2&gt;用户名：\" + this.username + \"&lt;/h2&gt;\"); out.println(\"&lt;h2&gt;密码：\" + this.password + \"&lt;/h2&gt;\"); &#125;&#125; Model2Java Web的Model2开发模型就是MVC思想的体现。 由JSP页面给Servlet提交了一个请求，然后由Servlet实例化一个JavaBean对象，然后由JavaBean访问数据库来读取数据并且反馈给Servlet，当Servlet得到结果后，根据结果提交给用户不同的JSP页面。","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"servlet","slug":"servlet","permalink":"http://yoursite.com/tags/servlet/"}]},{"title":"JSP学习笔记","date":"2017-12-18T06:36:52.000Z","path":"2017/12/18/JSP学习笔记/","text":"JSP学习笔记JSP简介JSP全名为Java Server Pages，其根本是一个简化的Servlet设计，实现了在Java当中使用HTML标签。是一种动态网页技术标准，与Servlet一样，在服务器端执行。拥有Java平台，安全性高，适合开发大型的，企业级的Web应用程序。 Web项目结构 JSP页面元素 JSP指令page：通常位于jsp页面的顶端，同一个页面可以有多个page指令。 &lt;%@page 属性1=“属性值” 属性2=“属性值“ …属性n=”属性值n”%&gt; 属性 描述 默认值 language 指定JSP页面使用的脚本语言 java import 通过该属性来引用脚本语言中使用到的类文件 无 contentType 用来制定JSP页面所采用的编码方式 text/html,ISO-8859-1 include：将一个外部文件嵌入到当前JSP文件中，同时解析这个页面中的JSP语句。 taglib：使用标签库定义新的自定义标签，在JSP页面中启动定制行为。 JSP注释HTML的注释：： 1&lt;!-- html注释 --&gt; //客户端可见 JSP的注释： 1&lt;%-- JSP注释 --%&gt; //客户端不可见 JSP脚本注释： 1234//单行注释/***多行注释*/ JSP脚本在JSP页面中通过&lt;% %&gt;标签执行的java代码。 1&lt;% out.println(\"Hello world!\") %&gt; JSP声明在JSP页面中定义变量或者方法。 1234567&lt;%! String name = \"张三\"; // 声明了一个字符串变量 int add(int x, int y) //声明了一个返回整形的方法，实现两个整数的求和 &#123; return x + y; &#125;%&gt; JSP表达式在JSP页面中执行的表达式 12345678910&lt;%! String name = \"张三\"; // 声明了一个字符串变量 int add(int x, int y) //声明了一个返回整形的方法，实现两个整数的求和 &#123; return x + y; &#125;%&gt;&lt;!-- 表达式不以；结尾 --&gt;你好，&lt;%=name %&gt;。&lt;br&gt;x + y = &lt;%=add(10,15) %&gt;&lt;br&gt; JSP页面生命周期 jspService()：方法被调用来处理客户端的请求。对每一个 请求，JSP引擎创建一个新的线程来处理该请求。如果有多个客户端同时请求该JSP文件，则JSP引擎会创建多个线程。以多线程的方式执行可以大大降低对系统的资源需求，提高系统的并发量及响应时间。 JSP内置对象JSP内置对象是Web容器创建的一组对象，不使用new关键字就可以使用的内置对象。 out对象JspWriter类的实例，向客户端输出内容的常用对象。 常用方法： 12345678void println() //向客户端打印字符串void clear() //清除缓冲区的内容，如果在flush之后调用会抛出异常void clearBuffer() //清楚缓冲区的内容，在flush之后调用不会抛出异常void flush() //将缓冲区内容输出到客户端int getBufferSize() //返回缓冲区的字节数的大小，如果不设缓冲区则为0int getRemaining() //返回缓冲区剩余大小boolean isAutoFlush() //返回缓冲区满时，是否自动清空还是抛出异常void close() //关闭输出流 request对象客户端的请求信息被封装在reqeust对象中，通过它才能了解到客户的需求，然后做出响应。HttpServletRequest类的实例。request对象具有请求域，即完成客户端的请求之前，该对象一直有效。 常用方法： 12345678String getParameter(String name) //返回name指定参数的参数值String[] getParameterValues(String name) //返回包含参数name的所有值的数组void setAttribute(String, Object) //存储此请求中的属性。object getAttribute(String name) //返回指定属性的属性值String getContentType() //得到请求体的MIME类型String getProtocol() //返回请求用的协议类型及版本号String getServerName() //返回接受请求的服务器主机名void setCharacterEncoding(String charEncoding) //设置字符编码 response对象包含了响应客户请求的有关信息。HttpServletResponse类的实例。response对象具有页面作用域，即访问一个页面时，该页面的response对象只能对这次访问有效，其他页面的response对象对当前页面无效。 常用方法： 1234String getCharacterEncoding() //返回响应用的是哪种字符编码void setContentType(String type) //设置响应的MIME类型PrintWriter getWriter() //返回可以向客户端输出字符的一个对象sendRedirect(String location) //重新定向客户端的请求 请求转发与请求重定向的区别 -请求转发：服务器行为，request.getRequestDispatcher().forward(request, response)是一次请求，转发后请求对象会保存,地址栏的URL地址不会改变。 -请求重定向：客户端行为，response.sendRedirect()，从本质上讲等同于两次请求，前一次的请求对象不会保存，地址栏的URL地址会改变。 session对象Web中的session指用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间。在服务器的内存中保存着不同用户的session。 session对象是JSP内置对象，HttpSession类的实例。 常用方法： 123456long getCreationTime() //返回session创建时间public String getId() //返回session创建时JSP引擎为他设的唯一ID值public Object setAttribute(String name, Object value) //使用指定名称将对象绑定到次会话public Object getAttribute(String name) //返回与此会话中的指定名称绑定在一起的对象，如果没有对象绑定在该名称下，则返回nullString[] getValueNames() //返回一个包含此session种所有可用属性的数组int getMaxInactiveInterval() //返回两次请求间隔多长时间此session被取消（单位秒） Session的生命周期 创建：当客户第一次访问某个jsp或者Servlet的时候，服务器会为当前会话创建一个SessionId，每次客户端向服务器端发送请求时，都会将此SessionId携带过去，服务器端会对此SessionId进行校验。 活动： 某次会话当中通过超链接打开的新页面会属于同一次会话。 只要当前会话页面没有全部关闭，重新打开新的浏览器窗口访问同一项目资源时属于同一次会话。 除非本次会话的所有页面都关闭后在重新访问某个jsp或者Servlet将会创建新的会话。 销毁： 调用了session.invalidate()方法。 Session过期（超时）。两种设置方式： 1session.setMaxInactiveInterval(时间) //单位是秒 在web.xml配置 123456&lt;!-- 设置会话10分钟后过期 --&gt;&lt;session-config&gt; &lt;session-timeout&gt; 10 &lt;/session-timeout&gt;&lt;/session-config&gt; 服务器重新启动。 ​ application对象 application对象实现了用户间数据的共享，可存放全局变量。 application开始于服务器的启动，终止于服务器的关闭。 在用户的前后连接或不同用户之间的连接中，可以对application对象的同一属性进行操作。 在任何地方对application对象属性的操作，都将影响到其他用户对此的访问。 application对象是ServletContext类的实例。 常用方法： 1234public void setAttribute(String name, Object value) //使用指定名称将对象绑定到此会话public Object getAttribute(String name) //返回此会话中的指定名称绑定在一起的对象，如果没有对象绑定在该名称下，则返回null。Enumeration getAttributeNames() //返回所有可用属性的枚举String getServerInfo() //返回JSP（Servlet）引擎名及版本号 page对象page对象就是指向当前JSP页面本身，java.lang.Object类的实例。 常用方法： 12345678910class getClass() //返回此Object的类int hashCode() //返回此Object的hash码boolean equals(Object obj) //判断此Object是否与指定的Object对象相等void copy(Object obj) //把此Object对象拷贝到指定的Object对象中Object clone() //克隆此Object对象String toString() //把此Object对象转换成String类的对象void notify() //唤醒一个等待的线程void notifyAll() //唤醒所有等待的线程void wait(int timeout) //使一个线程处于等待直到timeout结束或被唤醒void wait() //使一个线程处于等待直到被唤醒 pageContext对象 提供了对JSP页面内所有的对象及名字空间的访问 可以访问到本页所在的session，也可以获取本页面所在的application的某一属性值 相当于页面中所有功能的集合 常用方法： 12345678910JspWriter getOut() //返回当前客户端响应被使用的JspWriter流(out)HttpSession getSession() //返回当前页中的HttpSession对象(session)Object getPage() //返回当前页的Object对象(page)ServletRequest getRequest() //返回当前页的ServletRequest对象(request)ServletRequest getResponse() //返回当前页的ServletResponse对象(response)void setAttribute(String name, Object attribute) //设置属性及属性值Object getAttribute(String name, int scope) //在指定范围内取属性的值int getAttributeScope(String name) //返回某属性的作用范围void forward(String relativeUrlPath) //使当前页面重导到另一页面void include(String relativeUrlPath) //在当前位置包含另一文件 config对象config对象是在一个servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数（通过属性名和属性值构成）以及服务器的有关信息（通过传递一个ServletContext对象） 常用方法： 123ServletContext getServletContext() //返回含有服务器相关信息的ServletContext对象String getInitParameter(String name) //返回初始化参数的值Enumeratino getInitParameterNames() //返回Servlet初始化所需所有参数的枚举 exception对象exception对象是一个异常对象，当一个页面在运行过程中发生了异常，就产生这个对象。如果一个JSP页面要应用此对象，就必须把isErrorPage设为true，否则无法编译。它实际上是java.lang.Throwable的对象。 常用方法： 1234String getMessage() //返回描述异常的消息String toString() //返回关于异常的简短描述消息void printStackTrace() //显示异常及其栈轨迹Throwable FillInStackTrace() //重写异常的执行栈轨迹 JavabeanJavabean简介Javabeans就是符合某种特定规范的Java类。使用Javabeans的好处是解决代码重复编写，减少代码冗余，功能区分明确，提高代码的维护性。 Javabean设计原则 12345678910111213141516171819202122232425262728293031//公有学生类public class Students&#123; //私有属性 private String name; private int age; //无参的共有构造方法 public Students() &#123;&#125; //getter和setter方法 public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return this.name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return this.age; &#125;&#125; Jsp动作元素JSP动作元素（action elements），动作元素为请求处理阶段提供信息。动作元素遵循XML元素的语法，有一个包含元素名的开始标签，可以有属性、可选的内容、与开始标签匹配的结束标签。 在项目的src文件夹中创建com.po包和Users.java类： 12345678910111213141516171819202122232425262728package com.po;/*** 用户类**/public class Users &#123; private String username; //用户名 private String password; //密码 //保留此默认的构造方法 public Users() &#123;&#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; 用普通方法创建JavaBean：在index.jsp加入代码 12345678910111213......&lt;%@ page import=\"com.po.Users\" %&gt;......&lt;body&gt; &lt;% User user = new Users(); user.setUsername(\"admin\"); //设置用户名 user.setPassword(\"123456\"); //设置密码 %&gt; &lt;!-- 使用普通方法创建javabean的实例--&gt; 用户名：&lt;%=user.getUsername() %&gt;&lt;br&gt; 密码：&lt;%=user.getPassword() %&gt;&lt;br&gt;&lt;/body&gt; 使用JSP动作标签使用javabean： useBean：在jsp页面中实例化或者在指定范围内使用javabean。 1&lt;jsp:useBean id=\"标识符\" class=\"java类名\" scope=\"作用范围\" /&gt; 此方法不用加入&lt;%@ page import=”com.po.Users” %&gt;代码。 12345......&lt;!-- 使用useBean动作创建javabean的实例 --&gt;&lt;jsp:useBean id=\"myUsers\" class=\"com.po.Users\" scope=\"page\" /&gt;用户名：&lt;%=myUsers.getUsername() %&gt;密码：&lt;%=myUsers.getPassword() %&gt; setProperty：给已经实例化的JavaBean对象的属性赋值，一共有四种形式。 12345678&lt;!-- 跟表单关联 --&gt;&lt;jsp:setProperty name = \"JavaBean实例名\" property = \"*\" /&gt;&lt;!-- 跟表单关联,单个属性 --&gt;&lt;jsp:setProperty name = \"JavaBean实例名\" property = \"JavaBean属性名\" /&gt;&lt;!-- 手动设置数值 --&gt;&lt;jsp:setProperty name = \"JavaBean实例名\" property = \"JavaBean属性名\" value = \"BeanValue\"/&gt;&lt;!-- 跟request参数关联 --&gt;&lt;jsp:setProperty name = \"JavaBean实例名\" property = \"propertyName\" param = \"request对象中的参数名\" /&gt; login.jsp页面的表单： 12345678910...&lt;body&gt; &lt;form name=\"loginForm\" action=\"dologin.jsp\" method=\"post\"&gt; &lt;table&gt; &lt;tr&gt;&lt;td&gt;用户名：&lt;/td&gt;&lt;td&gt;&lt;input type=\"text\" name=\"username\" value=\"\" /&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;密码：&lt;/td&gt;&lt;td&gt;&lt;input type=\"password\" name=\"password\" value=\"\" /&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td colspan=\"2\" align=\"center\"&gt;&lt;input type=\"submit\" value=\"登陆\" /&gt;&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/body&gt; ​ dologin.jsp页面：如果在jsp:useBean标签class属性中的com.po.Users类有和表单对应的属性时，在jsp:setProperty标签中的property属性设置*，表示自动匹配。 1234567891011&lt;body&gt; &lt;jsp:useBean id=\"myUsers\" class=\"com.po.Users\" scope\"page\"/&gt; &lt;h1&gt; setProperty动作元素 &lt;/h1&gt; &lt;hr&gt; &lt;!-- 根据表单自动匹配所有属性 --&gt; &lt;jsp:setProperty name=\"myUsers\" property=\"*\" /&gt; 用户名：&lt;%=myUsers.getUsername() %&gt;&lt;br&gt; 密码：&lt;%=myUsers.getPassword() %&gt;&lt;br&gt;&lt;/body&gt; ​ getProperty：获取指定Javabean对象的属性值。 1&lt;jsp:getProperty name=\"JavaBean实例名\" property=\"属性名\" /&gt; 1234...用户名：&lt;jsp:getProperty name=\"myUsers\" property=\"username\" /&gt;密码：&lt;jsp:getProperty name=\"myUsers\" property=\"password\" /&gt;... ​ Javabean的四个作用域范围使用useBeans的Scope属性可以用来指定javabean的作用域范围 page：仅在当前页面有效。 request：可以通过HttpRequest.getAttribute()方式取得JavaBean对象。 session：可以通过HttpSession.getAttribute()方式取得JavaBean对象。 application：可以通过application.getAttribute()方法取得JavaBean对象。 1&lt;jsp:useBeans id=\"myUsers\" class=\"com.po.Users\" scope=\"page\" /&gt; ​ Model1在Model1模型之前，整个Web应用的情况几乎全部由JSP页面组成，JSP页面接收处理客户端的请求，对请求处理后直接做出响应，但是作用做回出现在界面层充斥着大量的业务逻辑和代码以及数据访问层的代码，Web程序的可扩展性和可维护性非常差。 JavaBean的出现可以使jsp页面中使用JavaBean封装的数据或者调用JavaBean的业务逻辑代码，作用大大提升了程序的可维护性。 分装DAO的java类： 123456789101112131415161718package com.dao;import com.po.Users;//用户的业务逻辑类public class UserDAO &#123; //用户的登陆方法 public boolean userLogin(Users u) &#123; //只允许用admin同时作为用户名和密码登陆 if(\"admin\".equals(u.getUsername()) &amp;&amp; \"admin\".equals(u.getPassword())) &#123; return true; &#125; else &#123; return false; &#125; &#125;&#125; Jsp状态管理http协议无状态性无状态是指当浏览器发送请求给服务器的时候，服务器响应客户端的请求，但是当同一个浏览器再次发送请求给服务器的时候，服务器无法分辨它是否刚才那个浏览器，所以有了保存用户状态的两大机制： Cookie Session Cookie简介中文名称为“小甜饼”，是Web服务器保存在客户端的一系列文本信息。 对特定用户的追踪 保存用户网页浏览的记录 简化登陆 安全风险：容易泄露用户信息 Cookie的创建与使用123456&lt;!-- 创建Cookie对象 --&gt;Cookie newCookie = Cookie(String key, Object value);&lt;!-- 写入Cookie对象 --&gt;response.addCookie(newCookie);&lt;!-- 读取Cookie对象 --&gt;Cookie[] cookies = request.getCookies(); 常用方法： 12345void setMaxAge(int expiry) //设置cookie的有效期，单位为秒void setValue(String value) //在创建cookie后，对cookie赋值String getName() //获取cookie的名称String getValue() //获取cookie的值int getMaxAge() //获取cookie的有效时间，单位为秒 login.jsp：多了一项cookie的选项。 1234567891011121314151617181920212223242526272829303132333435... &lt;% String username = \"\"; String password = \"\"; Cookie[] cookies = request.getCookies(); if(cookies != null &amp;&amp; cookies.length &gt; 0) &#123; for(Cookie c : cookies) &#123; if(c.getName().equals(\"username\")) &#123; username = c.getValue(); &#125; if(c.getName().equals(\"password\")) &#123; password = c.getValue(); &#125; &#125; &#125; &#125; %&gt;&lt;body&gt; &lt;h1&gt; 用户登录 &lt;/h1&gt; &lt;hr&gt; &lt;form name=\"loginForm\" action=\"dologin.jsp\" method=\"post\"&gt; &lt;table&gt; &lt;tr&gt;&lt;td&gt;用户名：&lt;/td&gt;&lt;td&gt;&lt;input type=\"text\" name=\"username\" value=\"&lt;%=username %&gt;\" /&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;密码：&lt;/td&gt;&lt;td&gt;&lt;input type=\"password\" name=\"password\" value=\"&lt;%=password %&gt;\" /&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td colspan=\"2\"&gt;&lt;input type=\"checkbox\" name=\"isUseCookie\" checked=\"checked\" value=\"十天内记住我的登录状态\" /&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td colspan=\"2\" align=\"center\"&gt;&lt;input type=\"submit\" value=\"登陆\" /&gt;&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/body&gt; dologin.jsp： 1234567891011121314151617181920212223242526272829303132&lt;% //首先判断用户是否选择了记住登录状态 String[] isUseCookies = request.getParameterValues(\"isUseCookie\"); if(isUseCookies != null &amp; isUseCookies.length &gt; 0) &#123; //不出现中文乱码 request.setCharacterEncoding(\"utf-8\"); //把用户名和密码保存在Cookie对象里 String username = request.getParameter(\"username\"); String password = request.getParameter(\"password\"); Cookie usernameCookie = new Cookie(\"username\", username); Cookie passwordCookie = new Cookie(\"password\", password); usernamCokie.setMaxAge(864000); //设置最大生命存期为10天 passwordCokie.setMaxAge(864000); response.addCookie(usernameCookie); response.addCookie(passwordCookie); &#125; else &#123; //如果用户没有勾选记住登录状态 Cookie[] cookies = request.getCookies(); if(cookies != null &amp;&amp; cookies.length &gt; 0) &#123; for(Cookie c : cookies) &#123; if(c.getName().equals(\"username\") || c.getName.equals(\"password\")) &#123; c.setMaxAge(0); //设置cookie失效 response.addCookie(c); //重新保存 &#125; &#125; &#125; &#125;%&gt;&lt;a href=\"users.jsp\" target=\"_blank\"&gt;查看用户信息&lt;/a&gt; users.jp: 1234567891011121314151617181920212223242526272829...&lt;body&gt; &lt;h1&gt; 用户信息 &lt;/h1&gt; &lt;hr&gt; &lt;% String username = \"\"; String password = \"\"; Cookie[] cookies = request.getCookies(); if(cookies != null &amp;&amp; cookies.length &gt; 0) &#123; for(Cookie c : cookies) &#123; if(c.getName().equals(\"username\")) &#123; username = c.getValue(); &#125; if(c.getName().equals(\"password\")) &#123; password = c.getValue(); &#125; &#125; &#125; &#125; %&gt; 用户名：&lt;%=username %&gt;&lt;br&gt; 密码：&lt;%=password %&gt;&lt;br&gt;&lt;/body&gt; Session与Cookie的对比 session cookie 在服务器端保存用户信息 在客户端保存用户信息 session中保存的是Object类型 cookie保存的是String类型 随会话的结束而将其存储的数据销毁 cookie可以长期保存在客户端 保存重要的信息 保存不重要的用户信息 Jsp指令与动作元素include指令1&lt;%@ include file=\"URL\" %&gt; include动作 page：要包含的页面。 flush：被包含的页面是否从缓冲区读取。 1&lt;jsp:include page=\"URL\" flush=\"true|false\" /&gt; include指令与include动作比较 include指令 jsp:include动作 语法格式 &lt;%@ include file=”..” %&gt; &amp;ltjsp:include page=”..” &amp;gt 发生作用的时间 页面转换期间 请求期间 包含的内容 文件的实际内容 页面的输出 转换成的Servlet 主页面和被包含页面转换为一个Servlet 主页面和被包含页面转换为独立的Servlet 编译时间 较慢，资源必须被解析 较快 执行时间 较慢 较慢，每次资源必须被解析 forward动作123&lt;jsp:forward page=\"URL\" /&gt;&lt;!-- 等同于 --&gt;request.getRequestDispatcher(\"/url\").forward(request, response); param动作1&lt;jsp:param name=\"参数名\" value=\"参数值\" /&gt; 常常与&amp;ltjsp:forward&amp;gt 一起使用，作为其子标签： 123456&lt;body&gt; &lt;jsp:forward page=\"user.jsp\"&gt; &lt;!-- 在接收从user.jsp从传递来的参数外还可以自己通过param标签添加额外的参数 --&gt; &lt;jsp:param value=\"admin@123.net\" name=\"email\" /&gt; &lt;/jsp:forward&gt;&lt;/body&gt;","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]}]